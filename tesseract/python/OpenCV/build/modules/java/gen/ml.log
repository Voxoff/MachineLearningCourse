ok: class CLASS ::.Ml : , name: Ml, base: 


===== Header: /home/guy/code/Voxoff/machineLearning/tesseract/python/OpenCV/modules/ml/include/opencv2/ml.hpp =====
Namespaces: set([u'cv', u'cv.ml'])

--- Incoming ---
[u'const cv.ml.VAR_NUMERICAL', u'0', [], []]
ok: CONST VAR_NUMERICAL=0

--- Incoming ---
[u'const cv.ml.VAR_ORDERED', u'0', [], []]
ok: CONST VAR_ORDERED=0

--- Incoming ---
[u'const cv.ml.VAR_CATEGORICAL', u'1', [], []]
ok: CONST VAR_CATEGORICAL=1

--- Incoming ---
[u'const cv.ml.TEST_ERROR', u'0', [], []]
ok: CONST TEST_ERROR=0

--- Incoming ---
[u'const cv.ml.TRAIN_ERROR', u'1', [], []]
ok: CONST TRAIN_ERROR=1

--- Incoming ---
[u'const cv.ml.ROW_SAMPLE', u'0', [], []]
ok: CONST ROW_SAMPLE=0

--- Incoming ---
[u'const cv.ml.COL_SAMPLE', u'1', [], []]
ok: CONST COL_SAMPLE=1

--- Incoming ---
[u'class cv.ml.TrainData', '', [], []]
ok: class CLASS cv.ml::.TrainData : , name: TrainData, base: 

--- Incoming ---
[u'cv.ml.TrainData.getLayout', u'int', [], [], u'int']
ok: FUNC <int cv.ml.TrainData.getLayout []>

--- Incoming ---
[u'cv.ml.TrainData.getNTrainSamples', u'int', [], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNTrainSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getNTestSamples', u'int', [], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNTestSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getNSamples', u'int', [], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getNVars', u'int', [], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNVars []>

--- Incoming ---
[u'cv.ml.TrainData.getNAllVars', u'int', [], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNAllVars []>

--- Incoming ---
[   u'cv.ml.TrainData.getSample',
    u'void',
    [],
    [   ['Mat', u'varIdx', '', []],
        [u'int', u'sidx', u'', []],
        [u'float*', u'buf', u'', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.getSample [ARG Mat varIdx=, ARG int sidx=, ARG float * buf=]>

--- Incoming ---
[u'cv.ml.TrainData.getSamples', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getMissing', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getMissing []>

--- Incoming ---
[   u'cv.ml.TrainData.getTrainSamples',
    u'Mat',
    [],
    [   [u'int', u'layout', u'ROW_SAMPLE', []],
        [u'bool', u'compressSamples', u'true', []],
        [u'bool', u'compressVars', u'true', []]],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSamples [ARG int layout=ROW_SAMPLE, ARG bool compressSamples=true, ARG bool compressVars=true]>

--- Incoming ---
[u'cv.ml.TrainData.getTrainResponses', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getTrainNormCatResponses', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainNormCatResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getTestResponses', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getTestNormCatResponses', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestNormCatResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getResponses', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getNormCatResponses', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getNormCatResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getSampleWeights', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSampleWeights []>

--- Incoming ---
[u'cv.ml.TrainData.getTrainSampleWeights', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSampleWeights []>

--- Incoming ---
[u'cv.ml.TrainData.getTestSampleWeights', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSampleWeights []>

--- Incoming ---
[u'cv.ml.TrainData.getVarIdx', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarIdx []>

--- Incoming ---
[u'cv.ml.TrainData.getVarType', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarType []>

--- Incoming ---
[u'cv.ml.TrainData.getVarSymbolFlags', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarSymbolFlags []>

--- Incoming ---
[u'cv.ml.TrainData.getResponseType', u'int', [], [], u'int']
ok: FUNC <int cv.ml.TrainData.getResponseType []>

--- Incoming ---
[u'cv.ml.TrainData.getTrainSampleIdx', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSampleIdx []>

--- Incoming ---
[u'cv.ml.TrainData.getTestSampleIdx', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSampleIdx []>

--- Incoming ---
[   u'cv.ml.TrainData.getValues',
    u'void',
    [],
    [   [u'int', u'vi', u'', []],
        ['Mat', u'sidx', '', []],
        [u'float*', u'values', u'', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.getValues [ARG int vi=, ARG Mat sidx=, ARG float * values=]>

--- Incoming ---
[u'cv.ml.TrainData.getDefaultSubstValues', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getDefaultSubstValues []>

--- Incoming ---
[   u'cv.ml.TrainData.getCatCount',
    u'int',
    [],
    [[u'int', u'vi', u'', []]],
    u'int']
ok: FUNC <int cv.ml.TrainData.getCatCount [ARG int vi=]>

--- Incoming ---
[u'cv.ml.TrainData.getClassLabels', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getClassLabels []>

--- Incoming ---
[u'cv.ml.TrainData.getCatOfs', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getCatOfs []>

--- Incoming ---
[u'cv.ml.TrainData.getCatMap', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getCatMap []>

--- Incoming ---
[   u'cv.ml.TrainData.setTrainTestSplit',
    u'void',
    [],
    [[u'int', u'count', u'', []], [u'bool', u'shuffle', u'true', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.setTrainTestSplit [ARG int count=, ARG bool shuffle=true]>

--- Incoming ---
[   u'cv.ml.TrainData.setTrainTestSplitRatio',
    u'void',
    [],
    [[u'double', u'ratio', u'', []], [u'bool', u'shuffle', u'true', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.setTrainTestSplitRatio [ARG double ratio=, ARG bool shuffle=true]>

--- Incoming ---
[u'cv.ml.TrainData.shuffleTrainTest', u'void', [], [], u'void']
ok: FUNC <void cv.ml.TrainData.shuffleTrainTest []>

--- Incoming ---
[u'cv.ml.TrainData.getTestSamples', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSamples []>

--- Incoming ---
[   u'cv.ml.TrainData.getNames',
    u'void',
    [],
    [[u'vector_String', u'names', u'', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.getNames [ARG vector_String names=]>

--- Incoming ---
[   u'cv.ml.TrainData.getSubVector',
    u'Mat',
    ['/S'],
    [[u'Mat', u'vec', u'', []], [u'Mat', u'idx', u'', []]],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSubVector [ARG Mat vec=, ARG Mat idx=]>

--- Incoming ---
[   u'cv.ml.TrainData.create',
    u'Ptr_TrainData',
    ['/S'],
    [   ['Mat', u'samples', '', []],
        [u'int', u'layout', u'', []],
        ['Mat', u'responses', '', []],
        ['Mat', u'varIdx', u'Mat()', []],
        ['Mat', u'sampleIdx', u'Mat()', []],
        ['Mat', u'sampleWeights', u'Mat()', []],
        ['Mat', u'varType', u'Mat()', []]],
    u'Ptr<TrainData>']
ok: FUNC <Ptr_TrainData cv.ml.TrainData.create [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG Mat varIdx=Mat(), ARG Mat sampleIdx=Mat(), ARG Mat sampleWeights=Mat(), ARG Mat varType=Mat()]>

--- Incoming ---
[u'class cv.ml.StatModel', ': cv::Algorithm', [], []]
ok: class CLASS cv.ml::.StatModel : Algorithm, name: StatModel, base: Algorithm

--- Incoming ---
[u'const cv.ml.StatModel.UPDATE_MODEL', u'1', [], []]
ok: CONST UPDATE_MODEL=1

--- Incoming ---
[u'const cv.ml.StatModel.RAW_OUTPUT', u'1', [], []]
ok: CONST RAW_OUTPUT=1

--- Incoming ---
[u'const cv.ml.StatModel.COMPRESSED_INPUT', u'2', [], []]
ok: CONST COMPRESSED_INPUT=2

--- Incoming ---
[u'const cv.ml.StatModel.PREPROCESSED_INPUT', u'4', [], []]
ok: CONST PREPROCESSED_INPUT=4

--- Incoming ---
[u'cv.ml.StatModel.getVarCount', u'int', [], [], u'int']
ok: FUNC <int cv.ml.StatModel.getVarCount []>

--- Incoming ---
[u'cv.ml.StatModel.empty', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ml.StatModel.empty []>

--- Incoming ---
[u'cv.ml.StatModel.isTrained', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ml.StatModel.isTrained []>

--- Incoming ---
[u'cv.ml.StatModel.isClassifier', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ml.StatModel.isClassifier []>

--- Incoming ---
[   u'cv.ml.StatModel.train',
    u'bool',
    [],
    [[u'Ptr_TrainData', u'trainData', u'', []], [u'int', u'flags', u'0', []]],
    u'bool']
ok: FUNC <bool cv.ml.StatModel.train [ARG Ptr_TrainData trainData=, ARG int flags=0]>

--- Incoming ---
[   u'cv.ml.StatModel.train',
    u'bool',
    [],
    [   ['Mat', u'samples', '', []],
        [u'int', u'layout', u'', []],
        ['Mat', u'responses', '', []]],
    u'bool']
ok: FUNC <bool cv.ml.StatModel.train [ARG Mat samples=, ARG int layout=, ARG Mat responses=]>

--- Incoming ---
[   u'cv.ml.StatModel.calcError',
    u'float',
    [],
    [   [u'Ptr_TrainData', u'data', u'', []],
        [u'bool', u'test', u'', []],
        ['Mat', u'resp', '', ['/O']]],
    u'float']
ok: FUNC <float cv.ml.StatModel.calcError [ARG Ptr_TrainData data=, ARG bool test=, ARG Mat resp=]>

--- Incoming ---
[   u'cv.ml.StatModel.predict',
    u'float',
    [],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'results', u'Mat()', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'float']
ok: FUNC <float cv.ml.StatModel.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>

--- Incoming ---
[u'class cv.ml.NormalBayesClassifier', u': cv::ml::StatModel', [], []]
ok: class CLASS cv.ml::.NormalBayesClassifier : StatModel, name: NormalBayesClassifier, base: StatModel

--- Incoming ---
[   u'cv.ml.NormalBayesClassifier.predictProb',
    u'float',
    [],
    [   ['Mat', u'inputs', '', []],
        ['Mat', u'outputs', '', ['/O']],
        ['Mat', u'outputProbs', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'float']
ok: FUNC <float cv.ml.NormalBayesClassifier.predictProb [ARG Mat inputs=, ARG Mat outputs=, ARG Mat outputProbs=, ARG int flags=0]>

--- Incoming ---
[   u'cv.ml.NormalBayesClassifier.create',
    u'Ptr_NormalBayesClassifier',
    ['/S'],
    [],
    u'Ptr<NormalBayesClassifier>']
ok: FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.create []>

--- Incoming ---
[u'class cv.ml.KNearest', u': cv::ml::StatModel', [], []]
ok: class CLASS cv.ml::.KNearest : StatModel, name: KNearest, base: StatModel

--- Incoming ---
[u'cv.ml.KNearest.getDefaultK', u'int', [], [], u'int']
ok: FUNC <int cv.ml.KNearest.getDefaultK []>

--- Incoming ---
[   u'cv.ml.KNearest.setDefaultK',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.KNearest.setDefaultK [ARG int val=]>

--- Incoming ---
[u'cv.ml.KNearest.getIsClassifier', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ml.KNearest.getIsClassifier []>

--- Incoming ---
[   u'cv.ml.KNearest.setIsClassifier',
    u'void',
    [],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.KNearest.setIsClassifier [ARG bool val=]>

--- Incoming ---
[u'cv.ml.KNearest.getEmax', u'int', [], [], u'int']
ok: FUNC <int cv.ml.KNearest.getEmax []>

--- Incoming ---
[u'cv.ml.KNearest.setEmax', u'void', [], [[u'int', u'val', u'', []]], u'void']
ok: FUNC <void cv.ml.KNearest.setEmax [ARG int val=]>

--- Incoming ---
[u'cv.ml.KNearest.getAlgorithmType', u'int', [], [], u'int']
ok: FUNC <int cv.ml.KNearest.getAlgorithmType []>

--- Incoming ---
[   u'cv.ml.KNearest.setAlgorithmType',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.KNearest.setAlgorithmType [ARG int val=]>

--- Incoming ---
[   u'cv.ml.KNearest.findNearest',
    u'float',
    [],
    [   ['Mat', u'samples', '', []],
        [u'int', u'k', u'', []],
        ['Mat', u'results', '', ['/O']],
        ['Mat', u'neighborResponses', u'Mat()', ['/O']],
        ['Mat', u'dist', u'Mat()', ['/O']]],
    u'float']
ok: FUNC <float cv.ml.KNearest.findNearest [ARG Mat samples=, ARG int k=, ARG Mat results=, ARG Mat neighborResponses=Mat(), ARG Mat dist=Mat()]>

--- Incoming ---
[u'const cv.ml.KNearest.BRUTE_FORCE', u'1', [], []]
ok: CONST BRUTE_FORCE=1

--- Incoming ---
[u'const cv.ml.KNearest.KDTREE', u'2', [], []]
ok: CONST KDTREE=2

--- Incoming ---
[u'cv.ml.KNearest.create', u'Ptr_KNearest', ['/S'], [], u'Ptr<KNearest>']
ok: FUNC <Ptr_KNearest cv.ml.KNearest.create []>

--- Incoming ---
[u'class cv.ml.SVM', u': cv::ml::StatModel', [], []]
ok: class CLASS cv.ml::.SVM : StatModel, name: SVM, base: StatModel

--- Incoming ---
[u'cv.ml.SVM.getType', u'int', [], [], u'int']
ok: FUNC <int cv.ml.SVM.getType []>

--- Incoming ---
[u'cv.ml.SVM.setType', u'void', [], [[u'int', u'val', u'', []]], u'void']
ok: FUNC <void cv.ml.SVM.setType [ARG int val=]>

--- Incoming ---
[u'cv.ml.SVM.getGamma', u'double', [], [], u'double']
ok: FUNC <double cv.ml.SVM.getGamma []>

--- Incoming ---
[u'cv.ml.SVM.setGamma', u'void', [], [[u'double', u'val', u'', []]], u'void']
ok: FUNC <void cv.ml.SVM.setGamma [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getCoef0', u'double', [], [], u'double']
ok: FUNC <double cv.ml.SVM.getCoef0 []>

--- Incoming ---
[u'cv.ml.SVM.setCoef0', u'void', [], [[u'double', u'val', u'', []]], u'void']
ok: FUNC <void cv.ml.SVM.setCoef0 [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getDegree', u'double', [], [], u'double']
ok: FUNC <double cv.ml.SVM.getDegree []>

--- Incoming ---
[u'cv.ml.SVM.setDegree', u'void', [], [[u'double', u'val', u'', []]], u'void']
ok: FUNC <void cv.ml.SVM.setDegree [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getC', u'double', [], [], u'double']
ok: FUNC <double cv.ml.SVM.getC []>

--- Incoming ---
[u'cv.ml.SVM.setC', u'void', [], [[u'double', u'val', u'', []]], u'void']
ok: FUNC <void cv.ml.SVM.setC [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getNu', u'double', [], [], u'double']
ok: FUNC <double cv.ml.SVM.getNu []>

--- Incoming ---
[u'cv.ml.SVM.setNu', u'void', [], [[u'double', u'val', u'', []]], u'void']
ok: FUNC <void cv.ml.SVM.setNu [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getP', u'double', [], [], u'double']
ok: FUNC <double cv.ml.SVM.getP []>

--- Incoming ---
[u'cv.ml.SVM.setP', u'void', [], [[u'double', u'val', u'', []]], u'void']
ok: FUNC <void cv.ml.SVM.setP [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getClassWeights', u'Mat', [], [], u'cv::Mat']
ok: FUNC <Mat cv.ml.SVM.getClassWeights []>

--- Incoming ---
[   u'cv.ml.SVM.setClassWeights',
    u'void',
    [],
    [[u'Mat', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setClassWeights [ARG Mat val=]>

--- Incoming ---
[u'cv.ml.SVM.getTermCriteria', u'TermCriteria', [], [], u'cv::TermCriteria']
ok: FUNC <TermCriteria cv.ml.SVM.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.SVM.setTermCriteria',
    u'void',
    [],
    [[u'TermCriteria', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[u'cv.ml.SVM.getKernelType', u'int', [], [], u'int']
ok: FUNC <int cv.ml.SVM.getKernelType []>

--- Incoming ---
[   u'cv.ml.SVM.setKernel',
    u'void',
    [],
    [[u'int', u'kernelType', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setKernel [ARG int kernelType=]>

--- Incoming ---
[u'const cv.ml.SVM.C_SVC', u'100', [], []]
ok: CONST C_SVC=100

--- Incoming ---
[u'const cv.ml.SVM.NU_SVC', u'101', [], []]
ok: CONST NU_SVC=101

--- Incoming ---
[u'const cv.ml.SVM.ONE_CLASS', u'102', [], []]
ok: CONST ONE_CLASS=102

--- Incoming ---
[u'const cv.ml.SVM.EPS_SVR', u'103', [], []]
ok: CONST EPS_SVR=103

--- Incoming ---
[u'const cv.ml.SVM.NU_SVR', u'104', [], []]
ok: CONST NU_SVR=104

--- Incoming ---
[u'const cv.ml.SVM.CUSTOM', u'-1', [], []]
ok: CONST CUSTOM=-1

--- Incoming ---
[u'const cv.ml.SVM.LINEAR', u'0', [], []]
ok: CONST LINEAR=0

--- Incoming ---
[u'const cv.ml.SVM.POLY', u'1', [], []]
ok: CONST POLY=1

--- Incoming ---
[u'const cv.ml.SVM.RBF', u'2', [], []]
ok: CONST RBF=2

--- Incoming ---
[u'const cv.ml.SVM.SIGMOID', u'3', [], []]
ok: CONST SIGMOID=3

--- Incoming ---
[u'const cv.ml.SVM.CHI2', u'4', [], []]
ok: CONST CHI2=4

--- Incoming ---
[u'const cv.ml.SVM.INTER', u'5', [], []]
ok: CONST INTER=5

--- Incoming ---
[u'const cv.ml.SVM.C', u'0', [], []]
ok: CONST C=0

--- Incoming ---
[u'const cv.ml.SVM.GAMMA', u'1', [], []]
ok: CONST GAMMA=1

--- Incoming ---
[u'const cv.ml.SVM.P', u'2', [], []]
ok: CONST P=2

--- Incoming ---
[u'const cv.ml.SVM.NU', u'3', [], []]
ok: CONST NU=3

--- Incoming ---
[u'const cv.ml.SVM.COEF', u'4', [], []]
ok: CONST COEF=4

--- Incoming ---
[u'const cv.ml.SVM.DEGREE', u'5', [], []]
ok: CONST DEGREE=5

--- Incoming ---
[u'cv.ml.SVM.getSupportVectors', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.SVM.getSupportVectors []>

--- Incoming ---
[u'cv.ml.SVM.getUncompressedSupportVectors', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.SVM.getUncompressedSupportVectors []>

--- Incoming ---
[   u'cv.ml.SVM.getDecisionFunction',
    u'double',
    [],
    [   [u'int', u'i', u'', []],
        ['Mat', u'alpha', '', ['/O']],
        ['Mat', u'svidx', '', ['/O']]],
    u'double']
ok: FUNC <double cv.ml.SVM.getDecisionFunction [ARG int i=, ARG Mat alpha=, ARG Mat svidx=]>

--- Incoming ---
[u'cv.ml.SVM.create', u'Ptr_SVM', ['/S'], [], u'Ptr<SVM>']
ok: FUNC <Ptr_SVM cv.ml.SVM.create []>

--- Incoming ---
[   u'cv.ml.SVM.load',
    u'Ptr_SVM',
    ['/S'],
    [[u'String', u'filepath', u'', []]],
    u'Ptr<SVM>']
ok: FUNC <Ptr_SVM cv.ml.SVM.load [ARG String filepath=]>

--- Incoming ---
[u'class cv.ml.EM', u': cv::ml::StatModel', [], []]
ok: class CLASS cv.ml::.EM : StatModel, name: EM, base: StatModel

--- Incoming ---
[u'const cv.ml.EM.COV_MAT_SPHERICAL', u'0', [], []]
ok: CONST COV_MAT_SPHERICAL=0

--- Incoming ---
[u'const cv.ml.EM.COV_MAT_DIAGONAL', u'1', [], []]
ok: CONST COV_MAT_DIAGONAL=1

--- Incoming ---
[u'const cv.ml.EM.COV_MAT_GENERIC', u'2', [], []]
ok: CONST COV_MAT_GENERIC=2

--- Incoming ---
[u'const cv.ml.EM.COV_MAT_DEFAULT', u'COV_MAT_DIAGONAL', [], []]
ok: CONST COV_MAT_DEFAULT=COV_MAT_DIAGONAL

--- Incoming ---
[u'const cv.ml.EM.DEFAULT_NCLUSTERS', u'5', [], []]
ok: CONST DEFAULT_NCLUSTERS=5

--- Incoming ---
[u'const cv.ml.EM.DEFAULT_MAX_ITERS', u'100', [], []]
ok: CONST DEFAULT_MAX_ITERS=100

--- Incoming ---
[u'const cv.ml.EM.START_E_STEP', u'1', [], []]
ok: CONST START_E_STEP=1

--- Incoming ---
[u'const cv.ml.EM.START_M_STEP', u'2', [], []]
ok: CONST START_M_STEP=2

--- Incoming ---
[u'const cv.ml.EM.START_AUTO_STEP', u'0', [], []]
ok: CONST START_AUTO_STEP=0

--- Incoming ---
[u'cv.ml.EM.getClustersNumber', u'int', [], [], u'int']
ok: FUNC <int cv.ml.EM.getClustersNumber []>

--- Incoming ---
[   u'cv.ml.EM.setClustersNumber',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.EM.setClustersNumber [ARG int val=]>

--- Incoming ---
[u'cv.ml.EM.getCovarianceMatrixType', u'int', [], [], u'int']
ok: FUNC <int cv.ml.EM.getCovarianceMatrixType []>

--- Incoming ---
[   u'cv.ml.EM.setCovarianceMatrixType',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.EM.setCovarianceMatrixType [ARG int val=]>

--- Incoming ---
[u'cv.ml.EM.getTermCriteria', u'TermCriteria', [], [], u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.EM.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.EM.setTermCriteria',
    u'void',
    [],
    [[u'TermCriteria', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.EM.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[u'cv.ml.EM.getWeights', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.EM.getWeights []>

--- Incoming ---
[u'cv.ml.EM.getMeans', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.EM.getMeans []>

--- Incoming ---
[   u'cv.ml.EM.getCovs',
    u'void',
    [],
    [[u'vector_Mat', u'covs', u'', ['/O']]],
    u'void']
ok: FUNC <void cv.ml.EM.getCovs [ARG vector_Mat covs=]>

--- Incoming ---
[   u'cv.ml.EM.predict2',
    u'Vec2d',
    [],
    [['Mat', u'sample', '', []], ['Mat', u'probs', '', ['/O']]],
    u'Vec2d']
ok: FUNC <Vec2d cv.ml.EM.predict2 [ARG Mat sample=, ARG Mat probs=]>

--- Incoming ---
[   u'cv.ml.EM.trainEM',
    u'bool',
    [],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'logLikelihoods', u'Mat()', ['/O']],
        ['Mat', u'labels', u'Mat()', ['/O']],
        ['Mat', u'probs', u'Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv.ml.EM.trainEM [ARG Mat samples=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
[   u'cv.ml.EM.trainE',
    u'bool',
    [],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'means0', '', []],
        ['Mat', u'covs0', u'Mat()', []],
        ['Mat', u'weights0', u'Mat()', []],
        ['Mat', u'logLikelihoods', u'Mat()', ['/O']],
        ['Mat', u'labels', u'Mat()', ['/O']],
        ['Mat', u'probs', u'Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv.ml.EM.trainE [ARG Mat samples=, ARG Mat means0=, ARG Mat covs0=Mat(), ARG Mat weights0=Mat(), ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
[   u'cv.ml.EM.trainM',
    u'bool',
    [],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'probs0', '', []],
        ['Mat', u'logLikelihoods', u'Mat()', ['/O']],
        ['Mat', u'labels', u'Mat()', ['/O']],
        ['Mat', u'probs', u'Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv.ml.EM.trainM [ARG Mat samples=, ARG Mat probs0=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
[u'cv.ml.EM.create', u'Ptr_EM', ['/S'], [], u'Ptr<EM>']
ok: FUNC <Ptr_EM cv.ml.EM.create []>

--- Incoming ---
[u'class cv.ml.DTrees', u': cv::ml::StatModel', [], []]
ok: class CLASS cv.ml::.DTrees : StatModel, name: DTrees, base: StatModel

--- Incoming ---
[u'const cv.ml.DTrees.PREDICT_AUTO', u'0', [], []]
ok: CONST PREDICT_AUTO=0

--- Incoming ---
[u'const cv.ml.DTrees.PREDICT_SUM', u'(1<<8)', [], []]
ok: CONST PREDICT_SUM=(1<<8)

--- Incoming ---
[u'const cv.ml.DTrees.PREDICT_MAX_VOTE', u'(2<<8)', [], []]
ok: CONST PREDICT_MAX_VOTE=(2<<8)

--- Incoming ---
[u'const cv.ml.DTrees.PREDICT_MASK', u'(3<<8)', [], []]
ok: CONST PREDICT_MASK=(3<<8)

--- Incoming ---
[u'cv.ml.DTrees.getMaxCategories', u'int', [], [], u'int']
ok: FUNC <int cv.ml.DTrees.getMaxCategories []>

--- Incoming ---
[   u'cv.ml.DTrees.setMaxCategories',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setMaxCategories [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getMaxDepth', u'int', [], [], u'int']
ok: FUNC <int cv.ml.DTrees.getMaxDepth []>

--- Incoming ---
[   u'cv.ml.DTrees.setMaxDepth',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setMaxDepth [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getMinSampleCount', u'int', [], [], u'int']
ok: FUNC <int cv.ml.DTrees.getMinSampleCount []>

--- Incoming ---
[   u'cv.ml.DTrees.setMinSampleCount',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setMinSampleCount [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getCVFolds', u'int', [], [], u'int']
ok: FUNC <int cv.ml.DTrees.getCVFolds []>

--- Incoming ---
[u'cv.ml.DTrees.setCVFolds', u'void', [], [[u'int', u'val', u'', []]], u'void']
ok: FUNC <void cv.ml.DTrees.setCVFolds [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getUseSurrogates', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ml.DTrees.getUseSurrogates []>

--- Incoming ---
[   u'cv.ml.DTrees.setUseSurrogates',
    u'void',
    [],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setUseSurrogates [ARG bool val=]>

--- Incoming ---
[u'cv.ml.DTrees.getUse1SERule', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ml.DTrees.getUse1SERule []>

--- Incoming ---
[   u'cv.ml.DTrees.setUse1SERule',
    u'void',
    [],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setUse1SERule [ARG bool val=]>

--- Incoming ---
[u'cv.ml.DTrees.getTruncatePrunedTree', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ml.DTrees.getTruncatePrunedTree []>

--- Incoming ---
[   u'cv.ml.DTrees.setTruncatePrunedTree',
    u'void',
    [],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setTruncatePrunedTree [ARG bool val=]>

--- Incoming ---
[u'cv.ml.DTrees.getRegressionAccuracy', u'float', [], [], u'float']
ok: FUNC <float cv.ml.DTrees.getRegressionAccuracy []>

--- Incoming ---
[   u'cv.ml.DTrees.setRegressionAccuracy',
    u'void',
    [],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setRegressionAccuracy [ARG float val=]>

--- Incoming ---
[u'cv.ml.DTrees.getPriors', u'Mat', [], [], u'cv::Mat']
ok: FUNC <Mat cv.ml.DTrees.getPriors []>

--- Incoming ---
[u'cv.ml.DTrees.setPriors', u'void', [], [[u'Mat', u'val', u'', []]], u'void']
ok: FUNC <void cv.ml.DTrees.setPriors [ARG Mat val=]>

--- Incoming ---
[u'cv.ml.DTrees.create', u'Ptr_DTrees', ['/S'], [], u'Ptr<DTrees>']
ok: FUNC <Ptr_DTrees cv.ml.DTrees.create []>

--- Incoming ---
[u'class cv.ml.RTrees', u': cv::ml::DTrees', [], []]
ok: class CLASS cv.ml::.RTrees : DTrees, name: RTrees, base: DTrees

--- Incoming ---
[u'cv.ml.RTrees.getCalculateVarImportance', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ml.RTrees.getCalculateVarImportance []>

--- Incoming ---
[   u'cv.ml.RTrees.setCalculateVarImportance',
    u'void',
    [],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.RTrees.setCalculateVarImportance [ARG bool val=]>

--- Incoming ---
[u'cv.ml.RTrees.getActiveVarCount', u'int', [], [], u'int']
ok: FUNC <int cv.ml.RTrees.getActiveVarCount []>

--- Incoming ---
[   u'cv.ml.RTrees.setActiveVarCount',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.RTrees.setActiveVarCount [ARG int val=]>

--- Incoming ---
[u'cv.ml.RTrees.getTermCriteria', u'TermCriteria', [], [], u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.RTrees.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.RTrees.setTermCriteria',
    u'void',
    [],
    [[u'TermCriteria', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.RTrees.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[u'cv.ml.RTrees.getVarImportance', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.RTrees.getVarImportance []>

--- Incoming ---
[u'cv.ml.RTrees.create', u'Ptr_RTrees', ['/S'], [], u'Ptr<RTrees>']
ok: FUNC <Ptr_RTrees cv.ml.RTrees.create []>

--- Incoming ---
[u'class cv.ml.Boost', u': cv::ml::DTrees', [], []]
ok: class CLASS cv.ml::.Boost : DTrees, name: Boost, base: DTrees

--- Incoming ---
[u'cv.ml.Boost.getBoostType', u'int', [], [], u'int']
ok: FUNC <int cv.ml.Boost.getBoostType []>

--- Incoming ---
[   u'cv.ml.Boost.setBoostType',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.Boost.setBoostType [ARG int val=]>

--- Incoming ---
[u'cv.ml.Boost.getWeakCount', u'int', [], [], u'int']
ok: FUNC <int cv.ml.Boost.getWeakCount []>

--- Incoming ---
[   u'cv.ml.Boost.setWeakCount',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.Boost.setWeakCount [ARG int val=]>

--- Incoming ---
[u'cv.ml.Boost.getWeightTrimRate', u'double', [], [], u'double']
ok: FUNC <double cv.ml.Boost.getWeightTrimRate []>

--- Incoming ---
[   u'cv.ml.Boost.setWeightTrimRate',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.Boost.setWeightTrimRate [ARG double val=]>

--- Incoming ---
[u'const cv.ml.Boost.DISCRETE', u'0', [], []]
ok: CONST DISCRETE=0

--- Incoming ---
[u'const cv.ml.Boost.REAL', u'1', [], []]
ok: CONST REAL=1

--- Incoming ---
[u'const cv.ml.Boost.LOGIT', u'2', [], []]
ok: CONST LOGIT=2

--- Incoming ---
[u'const cv.ml.Boost.GENTLE', u'3', [], []]
ok: CONST GENTLE=3

--- Incoming ---
[u'cv.ml.Boost.create', u'Ptr_Boost', ['/S'], [], u'Ptr<Boost>']
ok: FUNC <Ptr_Boost cv.ml.Boost.create []>

--- Incoming ---
[u'class cv.ml.ANN_MLP', u': cv::ml::StatModel', [], []]
ok: class CLASS cv.ml::.ANN_MLP : StatModel, name: ANN_MLP, base: StatModel

--- Incoming ---
[u'const cv.ml.ANN_MLP.BACKPROP', u'0', [], []]
ok: CONST BACKPROP=0

--- Incoming ---
[u'const cv.ml.ANN_MLP.RPROP', u'1', [], []]
ok: CONST RPROP=1

--- Incoming ---
[   u'cv.ml.ANN_MLP.setTrainMethod',
    u'void',
    [],
    [   [u'int', u'method', u'', []],
        [u'double', u'param1', u'0', []],
        [u'double', u'param2', u'0', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setTrainMethod [ARG int method=, ARG double param1=0, ARG double param2=0]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getTrainMethod', u'int', [], [], u'int']
ok: FUNC <int cv.ml.ANN_MLP.getTrainMethod []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setActivationFunction',
    u'void',
    [],
    [   [u'int', u'type', u'', []],
        [u'double', u'param1', u'0', []],
        [u'double', u'param2', u'0', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setActivationFunction [ARG int type=, ARG double param1=0, ARG double param2=0]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setLayerSizes',
    u'void',
    [],
    [['Mat', u'_layer_sizes', '', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setLayerSizes [ARG Mat _layer_sizes=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getLayerSizes', u'Mat', [], [], u'cv::Mat']
ok: FUNC <Mat cv.ml.ANN_MLP.getLayerSizes []>

--- Incoming ---
[u'cv.ml.ANN_MLP.getTermCriteria', u'TermCriteria', [], [], u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.ANN_MLP.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setTermCriteria',
    u'void',
    [],
    [[u'TermCriteria', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getBackpropWeightScale', u'double', [], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getBackpropWeightScale []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setBackpropWeightScale',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setBackpropWeightScale [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getBackpropMomentumScale', u'double', [], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getBackpropMomentumScale []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setBackpropMomentumScale',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setBackpropMomentumScale [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getRpropDW0', u'double', [], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDW0 []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDW0',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDW0 [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getRpropDWPlus', u'double', [], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWPlus []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWPlus',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWPlus [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getRpropDWMinus', u'double', [], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMinus []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWMinus',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMinus [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getRpropDWMin', u'double', [], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMin []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWMin',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMin [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getRpropDWMax', u'double', [], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMax []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWMax',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMax [ARG double val=]>

--- Incoming ---
[u'const cv.ml.ANN_MLP.IDENTITY', u'0', [], []]
ok: CONST IDENTITY=0

--- Incoming ---
[u'const cv.ml.ANN_MLP.SIGMOID_SYM', u'1', [], []]
ok: CONST SIGMOID_SYM=1

--- Incoming ---
[u'const cv.ml.ANN_MLP.GAUSSIAN', u'2', [], []]
ok: CONST GAUSSIAN=2

--- Incoming ---
[u'const cv.ml.ANN_MLP.UPDATE_WEIGHTS', u'1', [], []]
ok: CONST UPDATE_WEIGHTS=1

--- Incoming ---
[u'const cv.ml.ANN_MLP.NO_INPUT_SCALE', u'2', [], []]
ok: CONST NO_INPUT_SCALE=2

--- Incoming ---
[u'const cv.ml.ANN_MLP.NO_OUTPUT_SCALE', u'4', [], []]
ok: CONST NO_OUTPUT_SCALE=4

--- Incoming ---
[   u'cv.ml.ANN_MLP.getWeights',
    u'Mat',
    [],
    [[u'int', u'layerIdx', u'', []]],
    u'Mat']
ok: FUNC <Mat cv.ml.ANN_MLP.getWeights [ARG int layerIdx=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.create', u'Ptr_ANN_MLP', ['/S'], [], u'Ptr<ANN_MLP>']
ok: FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.create []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.load',
    u'Ptr_ANN_MLP',
    ['/S'],
    [[u'String', u'filepath', u'', []]],
    u'Ptr<ANN_MLP>']
ok: FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.load [ARG String filepath=]>

--- Incoming ---
[u'class cv.ml.LogisticRegression', u': cv::ml::StatModel', [], []]
ok: class CLASS cv.ml::.LogisticRegression : StatModel, name: LogisticRegression, base: StatModel

--- Incoming ---
[u'cv.ml.LogisticRegression.getLearningRate', u'double', [], [], u'double']
ok: FUNC <double cv.ml.LogisticRegression.getLearningRate []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setLearningRate',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setLearningRate [ARG double val=]>

--- Incoming ---
[u'cv.ml.LogisticRegression.getIterations', u'int', [], [], u'int']
ok: FUNC <int cv.ml.LogisticRegression.getIterations []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setIterations',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setIterations [ARG int val=]>

--- Incoming ---
[u'cv.ml.LogisticRegression.getRegularization', u'int', [], [], u'int']
ok: FUNC <int cv.ml.LogisticRegression.getRegularization []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setRegularization',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setRegularization [ARG int val=]>

--- Incoming ---
[u'cv.ml.LogisticRegression.getTrainMethod', u'int', [], [], u'int']
ok: FUNC <int cv.ml.LogisticRegression.getTrainMethod []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setTrainMethod',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setTrainMethod [ARG int val=]>

--- Incoming ---
[u'cv.ml.LogisticRegression.getMiniBatchSize', u'int', [], [], u'int']
ok: FUNC <int cv.ml.LogisticRegression.getMiniBatchSize []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setMiniBatchSize',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setMiniBatchSize [ARG int val=]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.getTermCriteria',
    u'TermCriteria',
    [],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.LogisticRegression.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setTermCriteria',
    u'void',
    [],
    [[u'TermCriteria', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[u'const cv.ml.LogisticRegression.REG_DISABLE', u'-1', [], []]
ok: CONST REG_DISABLE=-1

--- Incoming ---
[u'const cv.ml.LogisticRegression.REG_L1', u'0', [], []]
ok: CONST REG_L1=0

--- Incoming ---
[u'const cv.ml.LogisticRegression.REG_L2', u'1', [], []]
ok: CONST REG_L2=1

--- Incoming ---
[u'const cv.ml.LogisticRegression.BATCH', u'0', [], []]
ok: CONST BATCH=0

--- Incoming ---
[u'const cv.ml.LogisticRegression.MINI_BATCH', u'1', [], []]
ok: CONST MINI_BATCH=1

--- Incoming ---
[   u'cv.ml.LogisticRegression.predict',
    u'float',
    [],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'results', u'Mat()', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'float']
ok: FUNC <float cv.ml.LogisticRegression.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>

--- Incoming ---
[u'cv.ml.LogisticRegression.get_learnt_thetas', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.LogisticRegression.get_learnt_thetas []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.create',
    u'Ptr_LogisticRegression',
    ['/S'],
    [],
    u'Ptr<LogisticRegression>']
ok: FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.create []>

--- Incoming ---
[u'class cv.ml.SVMSGD', u': cv::ml::StatModel', [], []]
ok: class CLASS cv.ml::.SVMSGD : StatModel, name: SVMSGD, base: StatModel

--- Incoming ---
[u'const cv.ml.SVMSGD.SGD', '0', [], []]
ok: CONST SGD=0

--- Incoming ---
[u'const cv.ml.SVMSGD.ASGD', '1', [], []]
ok: CONST ASGD=1

--- Incoming ---
[u'const cv.ml.SVMSGD.SOFT_MARGIN', '0', [], []]
ok: CONST SOFT_MARGIN=0

--- Incoming ---
[u'const cv.ml.SVMSGD.HARD_MARGIN', '1', [], []]
ok: CONST HARD_MARGIN=1

--- Incoming ---
[u'cv.ml.SVMSGD.getWeights', u'Mat', [], [], u'Mat']
ok: FUNC <Mat cv.ml.SVMSGD.getWeights []>

--- Incoming ---
[u'cv.ml.SVMSGD.getShift', u'float', [], [], u'float']
ok: FUNC <float cv.ml.SVMSGD.getShift []>

--- Incoming ---
[u'cv.ml.SVMSGD.create', u'Ptr_SVMSGD', ['/S'], [], u'Ptr<SVMSGD>']
ok: FUNC <Ptr_SVMSGD cv.ml.SVMSGD.create []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setOptimalParameters',
    u'void',
    [],
    [   [u'int', u'svmsgdType', u'SVMSGD::ASGD', []],
        [u'int', u'marginType', u'SVMSGD::SOFT_MARGIN', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setOptimalParameters [ARG int svmsgdType=SVMSGD::ASGD, ARG int marginType=SVMSGD::SOFT_MARGIN]>

--- Incoming ---
[u'cv.ml.SVMSGD.getSvmsgdType', u'int', [], [], u'int']
ok: FUNC <int cv.ml.SVMSGD.getSvmsgdType []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setSvmsgdType',
    u'void',
    [],
    [[u'int', u'svmsgdType', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setSvmsgdType [ARG int svmsgdType=]>

--- Incoming ---
[u'cv.ml.SVMSGD.getMarginType', u'int', [], [], u'int']
ok: FUNC <int cv.ml.SVMSGD.getMarginType []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setMarginType',
    u'void',
    [],
    [[u'int', u'marginType', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setMarginType [ARG int marginType=]>

--- Incoming ---
[u'cv.ml.SVMSGD.getMarginRegularization', u'float', [], [], u'float']
ok: FUNC <float cv.ml.SVMSGD.getMarginRegularization []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setMarginRegularization',
    u'void',
    [],
    [[u'float', u'marginRegularization', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setMarginRegularization [ARG float marginRegularization=]>

--- Incoming ---
[u'cv.ml.SVMSGD.getInitialStepSize', u'float', [], [], u'float']
ok: FUNC <float cv.ml.SVMSGD.getInitialStepSize []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setInitialStepSize',
    u'void',
    [],
    [[u'float', u'InitialStepSize', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setInitialStepSize [ARG float InitialStepSize=]>

--- Incoming ---
[u'cv.ml.SVMSGD.getStepDecreasingPower', u'float', [], [], u'float']
ok: FUNC <float cv.ml.SVMSGD.getStepDecreasingPower []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setStepDecreasingPower',
    u'void',
    [],
    [[u'float', u'stepDecreasingPower', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setStepDecreasingPower [ARG float stepDecreasingPower=]>

--- Incoming ---
[u'cv.ml.SVMSGD.getTermCriteria', u'TermCriteria', [], [], u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.SVMSGD.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setTermCriteria',
    u'void',
    [],
    [[u'TermCriteria', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setTermCriteria [ARG TermCriteria val=]>


===== Header: /home/guy/code/Voxoff/machineLearning/tesseract/python/OpenCV/modules/ml/include/opencv2/ml/ml.hpp =====
Namespaces: set([u'cv', u'cv.ml'])
Ignore header: /home/guy/code/Voxoff/machineLearning/tesseract/python/OpenCV/modules/ml/include/opencv2/ml/ml.hpp


===== Generating... =====
CLASS cv.ml::.EM : StatModel
[CONST COV_MAT_SPHERICAL=0, CONST COV_MAT_DIAGONAL=1, CONST COV_MAT_GENERIC=2, CONST COV_MAT_DEFAULT=COV_MAT_DIAGONAL, CONST DEFAULT_NCLUSTERS=5, CONST DEFAULT_MAX_ITERS=100, CONST START_E_STEP=1, CONST START_M_STEP=2, CONST START_AUTO_STEP=0]
FUNC <Mat cv.ml.EM.getMeans []>
java: Mat getMeans()
FUNC <Mat cv.ml.EM.getWeights []>
java: Mat getWeights()
FUNC <Ptr_EM cv.ml.EM.create []>
java: EM create()
FUNC <TermCriteria cv.ml.EM.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <Vec2d cv.ml.EM.predict2 [ARG Mat sample=, ARG Mat probs=]>
java: double[] predict2(Mat sample, Mat probs)
FUNC <bool cv.ml.EM.trainE [ARG Mat samples=, ARG Mat means0=, ARG Mat covs0=Mat(), ARG Mat weights0=Mat(), ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainE(Mat samples, Mat means0)
FUNC <bool cv.ml.EM.trainEM [ARG Mat samples=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainEM(Mat samples, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainEM(Mat samples)
FUNC <bool cv.ml.EM.trainM [ARG Mat samples=, ARG Mat probs0=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainM(Mat samples, Mat probs0, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainM(Mat samples, Mat probs0)
FUNC <int cv.ml.EM.getClustersNumber []>
java: int getClustersNumber()
FUNC <int cv.ml.EM.getCovarianceMatrixType []>
java: int getCovarianceMatrixType()
FUNC <void cv.ml.EM.getCovs [ARG vector_Mat covs=]>
java: void getCovs(List<Mat> covs)
FUNC <void cv.ml.EM.setClustersNumber [ARG int val=]>
java: void setClustersNumber(int val)
FUNC <void cv.ml.EM.setCovarianceMatrixType [ARG int val=]>
java: void setCovarianceMatrixType(int val)
FUNC <void cv.ml.EM.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
CLASS cv.ml::.SVM : StatModel
[CONST C_SVC=100, CONST NU_SVC=101, CONST ONE_CLASS=102, CONST EPS_SVR=103, CONST NU_SVR=104, CONST CUSTOM=-1, CONST LINEAR=0, CONST POLY=1, CONST RBF=2, CONST SIGMOID=3, CONST CHI2=4, CONST INTER=5, CONST C=0, CONST GAMMA=1, CONST P=2, CONST NU=3, CONST COEF=4, CONST DEGREE=5]
FUNC <Mat cv.ml.SVM.getClassWeights []>
java: Mat getClassWeights()
FUNC <Mat cv.ml.SVM.getSupportVectors []>
java: Mat getSupportVectors()
FUNC <Mat cv.ml.SVM.getUncompressedSupportVectors []>
java: Mat getUncompressedSupportVectors()
FUNC <Ptr_SVM cv.ml.SVM.create []>
java: SVM create()
FUNC <Ptr_SVM cv.ml.SVM.load [ARG String filepath=]>
java: SVM load(String filepath)
FUNC <TermCriteria cv.ml.SVM.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <double cv.ml.SVM.getC []>
java: double getC()
FUNC <double cv.ml.SVM.getCoef0 []>
java: double getCoef0()
FUNC <double cv.ml.SVM.getDecisionFunction [ARG int i=, ARG Mat alpha=, ARG Mat svidx=]>
java: double getDecisionFunction(int i, Mat alpha, Mat svidx)
FUNC <double cv.ml.SVM.getDegree []>
java: double getDegree()
FUNC <double cv.ml.SVM.getGamma []>
java: double getGamma()
FUNC <double cv.ml.SVM.getNu []>
java: double getNu()
FUNC <double cv.ml.SVM.getP []>
java: double getP()
FUNC <int cv.ml.SVM.getKernelType []>
java: int getKernelType()
FUNC <int cv.ml.SVM.getType []>
java: int getType()
FUNC <void cv.ml.SVM.setC [ARG double val=]>
java: void setC(double val)
FUNC <void cv.ml.SVM.setClassWeights [ARG Mat val=]>
java: void setClassWeights(Mat val)
FUNC <void cv.ml.SVM.setCoef0 [ARG double val=]>
java: void setCoef0(double val)
FUNC <void cv.ml.SVM.setDegree [ARG double val=]>
java: void setDegree(double val)
FUNC <void cv.ml.SVM.setGamma [ARG double val=]>
java: void setGamma(double val)
FUNC <void cv.ml.SVM.setKernel [ARG int kernelType=]>
java: void setKernel(int kernelType)
FUNC <void cv.ml.SVM.setNu [ARG double val=]>
java: void setNu(double val)
FUNC <void cv.ml.SVM.setP [ARG double val=]>
java: void setP(double val)
FUNC <void cv.ml.SVM.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <void cv.ml.SVM.setType [ARG int val=]>
java: void setType(int val)
CLASS ::.Ml : 
[CONST VAR_NUMERICAL=0, CONST VAR_ORDERED=0, CONST VAR_CATEGORICAL=1, CONST TEST_ERROR=0, CONST TRAIN_ERROR=1, CONST ROW_SAMPLE=0, CONST COL_SAMPLE=1]
CLASS cv.ml::.NormalBayesClassifier : StatModel
FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.create []>
java: NormalBayesClassifier create()
FUNC <float cv.ml.NormalBayesClassifier.predictProb [ARG Mat inputs=, ARG Mat outputs=, ARG Mat outputProbs=, ARG int flags=0]>
java: float predictProb(Mat inputs, Mat outputs, Mat outputProbs, int flags)
java: float predictProb(Mat inputs, Mat outputs, Mat outputProbs)
CLASS cv.ml::.TrainData : 
FUNC <Mat cv.ml.TrainData.getCatMap []>
java: Mat getCatMap()
FUNC <Mat cv.ml.TrainData.getCatOfs []>
java: Mat getCatOfs()
FUNC <Mat cv.ml.TrainData.getClassLabels []>
java: Mat getClassLabels()
FUNC <Mat cv.ml.TrainData.getDefaultSubstValues []>
java: Mat getDefaultSubstValues()
FUNC <Mat cv.ml.TrainData.getMissing []>
java: Mat getMissing()
FUNC <Mat cv.ml.TrainData.getNormCatResponses []>
java: Mat getNormCatResponses()
FUNC <Mat cv.ml.TrainData.getResponses []>
java: Mat getResponses()
FUNC <Mat cv.ml.TrainData.getSampleWeights []>
java: Mat getSampleWeights()
FUNC <Mat cv.ml.TrainData.getSamples []>
java: Mat getSamples()
FUNC <Mat cv.ml.TrainData.getSubVector [ARG Mat vec=, ARG Mat idx=]>
java: Mat getSubVector(Mat vec, Mat idx)
FUNC <Mat cv.ml.TrainData.getTestNormCatResponses []>
java: Mat getTestNormCatResponses()
FUNC <Mat cv.ml.TrainData.getTestResponses []>
java: Mat getTestResponses()
FUNC <Mat cv.ml.TrainData.getTestSampleIdx []>
java: Mat getTestSampleIdx()
FUNC <Mat cv.ml.TrainData.getTestSampleWeights []>
java: Mat getTestSampleWeights()
FUNC <Mat cv.ml.TrainData.getTestSamples []>
java: Mat getTestSamples()
FUNC <Mat cv.ml.TrainData.getTrainNormCatResponses []>
java: Mat getTrainNormCatResponses()
FUNC <Mat cv.ml.TrainData.getTrainResponses []>
java: Mat getTrainResponses()
FUNC <Mat cv.ml.TrainData.getTrainSampleIdx []>
java: Mat getTrainSampleIdx()
FUNC <Mat cv.ml.TrainData.getTrainSampleWeights []>
java: Mat getTrainSampleWeights()
FUNC <Mat cv.ml.TrainData.getTrainSamples [ARG int layout=ROW_SAMPLE, ARG bool compressSamples=true, ARG bool compressVars=true]>
java: Mat getTrainSamples(int layout, boolean compressSamples, boolean compressVars)
java: Mat getTrainSamples()
FUNC <Mat cv.ml.TrainData.getVarIdx []>
java: Mat getVarIdx()
FUNC <Mat cv.ml.TrainData.getVarSymbolFlags []>
java: Mat getVarSymbolFlags()
FUNC <Mat cv.ml.TrainData.getVarType []>
java: Mat getVarType()
FUNC <Ptr_TrainData cv.ml.TrainData.create [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG Mat varIdx=Mat(), ARG Mat sampleIdx=Mat(), ARG Mat sampleWeights=Mat(), ARG Mat varType=Mat()]>
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx, Mat sampleIdx, Mat sampleWeights, Mat varType)
java: TrainData create(Mat samples, int layout, Mat responses)
FUNC <int cv.ml.TrainData.getCatCount [ARG int vi=]>
java: int getCatCount(int vi)
FUNC <int cv.ml.TrainData.getLayout []>
java: int getLayout()
FUNC <int cv.ml.TrainData.getNAllVars []>
java: int getNAllVars()
FUNC <int cv.ml.TrainData.getNSamples []>
java: int getNSamples()
FUNC <int cv.ml.TrainData.getNTestSamples []>
java: int getNTestSamples()
FUNC <int cv.ml.TrainData.getNTrainSamples []>
java: int getNTrainSamples()
FUNC <int cv.ml.TrainData.getNVars []>
java: int getNVars()
FUNC <int cv.ml.TrainData.getResponseType []>
java: int getResponseType()
FUNC <void cv.ml.TrainData.getNames [ARG vector_String names=]>
SKIP:void getNames(vector_String names)	 due to ARG typevector_String/I
FUNC <void cv.ml.TrainData.getSample [ARG Mat varIdx=, ARG int sidx=, ARG float * buf=]>
java: void getSample(Mat varIdx, int sidx, float buf)
FUNC <void cv.ml.TrainData.getValues [ARG int vi=, ARG Mat sidx=, ARG float * values=]>
java: void getValues(int vi, Mat sidx, float values)
FUNC <void cv.ml.TrainData.setTrainTestSplit [ARG int count=, ARG bool shuffle=true]>
java: void setTrainTestSplit(int count, boolean shuffle)
java: void setTrainTestSplit(int count)
FUNC <void cv.ml.TrainData.setTrainTestSplitRatio [ARG double ratio=, ARG bool shuffle=true]>
java: void setTrainTestSplitRatio(double ratio, boolean shuffle)
java: void setTrainTestSplitRatio(double ratio)
FUNC <void cv.ml.TrainData.shuffleTrainTest []>
java: void shuffleTrainTest()
CLASS cv.ml::.Boost : DTrees
[CONST DISCRETE=0, CONST REAL=1, CONST LOGIT=2, CONST GENTLE=3]
FUNC <Ptr_Boost cv.ml.Boost.create []>
java: Boost create()
FUNC <double cv.ml.Boost.getWeightTrimRate []>
java: double getWeightTrimRate()
FUNC <int cv.ml.Boost.getBoostType []>
java: int getBoostType()
FUNC <int cv.ml.Boost.getWeakCount []>
java: int getWeakCount()
FUNC <void cv.ml.Boost.setBoostType [ARG int val=]>
java: void setBoostType(int val)
FUNC <void cv.ml.Boost.setWeakCount [ARG int val=]>
java: void setWeakCount(int val)
FUNC <void cv.ml.Boost.setWeightTrimRate [ARG double val=]>
java: void setWeightTrimRate(double val)
CLASS cv.ml::.LogisticRegression : StatModel
[CONST REG_DISABLE=-1, CONST REG_L1=0, CONST REG_L2=1, CONST BATCH=0, CONST MINI_BATCH=1]
FUNC <Mat cv.ml.LogisticRegression.get_learnt_thetas []>
java: Mat get_learnt_thetas()
FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.create []>
java: LogisticRegression create()
FUNC <TermCriteria cv.ml.LogisticRegression.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <double cv.ml.LogisticRegression.getLearningRate []>
java: double getLearningRate()
FUNC <float cv.ml.LogisticRegression.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>
java: float predict(Mat samples, Mat results, int flags)
java: float predict(Mat samples)
FUNC <int cv.ml.LogisticRegression.getIterations []>
java: int getIterations()
FUNC <int cv.ml.LogisticRegression.getMiniBatchSize []>
java: int getMiniBatchSize()
FUNC <int cv.ml.LogisticRegression.getRegularization []>
java: int getRegularization()
FUNC <int cv.ml.LogisticRegression.getTrainMethod []>
java: int getTrainMethod()
FUNC <void cv.ml.LogisticRegression.setIterations [ARG int val=]>
java: void setIterations(int val)
FUNC <void cv.ml.LogisticRegression.setLearningRate [ARG double val=]>
java: void setLearningRate(double val)
FUNC <void cv.ml.LogisticRegression.setMiniBatchSize [ARG int val=]>
java: void setMiniBatchSize(int val)
FUNC <void cv.ml.LogisticRegression.setRegularization [ARG int val=]>
java: void setRegularization(int val)
FUNC <void cv.ml.LogisticRegression.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <void cv.ml.LogisticRegression.setTrainMethod [ARG int val=]>
java: void setTrainMethod(int val)
CLASS cv.ml::.KNearest : StatModel
[CONST BRUTE_FORCE=1, CONST KDTREE=2]
FUNC <Ptr_KNearest cv.ml.KNearest.create []>
java: KNearest create()
FUNC <bool cv.ml.KNearest.getIsClassifier []>
java: boolean getIsClassifier()
FUNC <float cv.ml.KNearest.findNearest [ARG Mat samples=, ARG int k=, ARG Mat results=, ARG Mat neighborResponses=Mat(), ARG Mat dist=Mat()]>
java: float findNearest(Mat samples, int k, Mat results, Mat neighborResponses, Mat dist)
java: float findNearest(Mat samples, int k, Mat results)
FUNC <int cv.ml.KNearest.getAlgorithmType []>
java: int getAlgorithmType()
FUNC <int cv.ml.KNearest.getDefaultK []>
java: int getDefaultK()
FUNC <int cv.ml.KNearest.getEmax []>
java: int getEmax()
FUNC <void cv.ml.KNearest.setAlgorithmType [ARG int val=]>
java: void setAlgorithmType(int val)
FUNC <void cv.ml.KNearest.setDefaultK [ARG int val=]>
java: void setDefaultK(int val)
FUNC <void cv.ml.KNearest.setEmax [ARG int val=]>
java: void setEmax(int val)
FUNC <void cv.ml.KNearest.setIsClassifier [ARG bool val=]>
java: void setIsClassifier(boolean val)
CLASS cv.ml::.SVMSGD : StatModel
[CONST SGD=0, CONST ASGD=1, CONST SOFT_MARGIN=0, CONST HARD_MARGIN=1]
FUNC <Mat cv.ml.SVMSGD.getWeights []>
java: Mat getWeights()
FUNC <Ptr_SVMSGD cv.ml.SVMSGD.create []>
java: SVMSGD create()
FUNC <TermCriteria cv.ml.SVMSGD.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <float cv.ml.SVMSGD.getInitialStepSize []>
java: float getInitialStepSize()
FUNC <float cv.ml.SVMSGD.getMarginRegularization []>
java: float getMarginRegularization()
FUNC <float cv.ml.SVMSGD.getShift []>
java: float getShift()
FUNC <float cv.ml.SVMSGD.getStepDecreasingPower []>
java: float getStepDecreasingPower()
FUNC <int cv.ml.SVMSGD.getMarginType []>
java: int getMarginType()
FUNC <int cv.ml.SVMSGD.getSvmsgdType []>
java: int getSvmsgdType()
FUNC <void cv.ml.SVMSGD.setInitialStepSize [ARG float InitialStepSize=]>
java: void setInitialStepSize(float InitialStepSize)
FUNC <void cv.ml.SVMSGD.setMarginRegularization [ARG float marginRegularization=]>
java: void setMarginRegularization(float marginRegularization)
FUNC <void cv.ml.SVMSGD.setMarginType [ARG int marginType=]>
java: void setMarginType(int marginType)
FUNC <void cv.ml.SVMSGD.setOptimalParameters [ARG int svmsgdType=SVMSGD::ASGD, ARG int marginType=SVMSGD::SOFT_MARGIN]>
java: void setOptimalParameters(int svmsgdType, int marginType)
java: void setOptimalParameters()
FUNC <void cv.ml.SVMSGD.setStepDecreasingPower [ARG float stepDecreasingPower=]>
java: void setStepDecreasingPower(float stepDecreasingPower)
FUNC <void cv.ml.SVMSGD.setSvmsgdType [ARG int svmsgdType=]>
java: void setSvmsgdType(int svmsgdType)
FUNC <void cv.ml.SVMSGD.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
CLASS cv.ml::.DTrees : StatModel
[CONST PREDICT_AUTO=0, CONST PREDICT_SUM=(1<<8), CONST PREDICT_MAX_VOTE=(2<<8), CONST PREDICT_MASK=(3<<8)]
FUNC <Mat cv.ml.DTrees.getPriors []>
java: Mat getPriors()
FUNC <Ptr_DTrees cv.ml.DTrees.create []>
java: DTrees create()
FUNC <bool cv.ml.DTrees.getTruncatePrunedTree []>
java: boolean getTruncatePrunedTree()
FUNC <bool cv.ml.DTrees.getUse1SERule []>
java: boolean getUse1SERule()
FUNC <bool cv.ml.DTrees.getUseSurrogates []>
java: boolean getUseSurrogates()
FUNC <float cv.ml.DTrees.getRegressionAccuracy []>
java: float getRegressionAccuracy()
FUNC <int cv.ml.DTrees.getCVFolds []>
java: int getCVFolds()
FUNC <int cv.ml.DTrees.getMaxCategories []>
java: int getMaxCategories()
FUNC <int cv.ml.DTrees.getMaxDepth []>
java: int getMaxDepth()
FUNC <int cv.ml.DTrees.getMinSampleCount []>
java: int getMinSampleCount()
FUNC <void cv.ml.DTrees.setCVFolds [ARG int val=]>
java: void setCVFolds(int val)
FUNC <void cv.ml.DTrees.setMaxCategories [ARG int val=]>
java: void setMaxCategories(int val)
FUNC <void cv.ml.DTrees.setMaxDepth [ARG int val=]>
java: void setMaxDepth(int val)
FUNC <void cv.ml.DTrees.setMinSampleCount [ARG int val=]>
java: void setMinSampleCount(int val)
FUNC <void cv.ml.DTrees.setPriors [ARG Mat val=]>
java: void setPriors(Mat val)
FUNC <void cv.ml.DTrees.setRegressionAccuracy [ARG float val=]>
java: void setRegressionAccuracy(float val)
FUNC <void cv.ml.DTrees.setTruncatePrunedTree [ARG bool val=]>
java: void setTruncatePrunedTree(boolean val)
FUNC <void cv.ml.DTrees.setUse1SERule [ARG bool val=]>
java: void setUse1SERule(boolean val)
FUNC <void cv.ml.DTrees.setUseSurrogates [ARG bool val=]>
java: void setUseSurrogates(boolean val)
CLASS cv.ml::.ANN_MLP : StatModel
[CONST BACKPROP=0, CONST RPROP=1, CONST IDENTITY=0, CONST SIGMOID_SYM=1, CONST GAUSSIAN=2, CONST UPDATE_WEIGHTS=1, CONST NO_INPUT_SCALE=2, CONST NO_OUTPUT_SCALE=4]
FUNC <Mat cv.ml.ANN_MLP.getLayerSizes []>
java: Mat getLayerSizes()
FUNC <Mat cv.ml.ANN_MLP.getWeights [ARG int layerIdx=]>
java: Mat getWeights(int layerIdx)
FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.create []>
java: ANN_MLP create()
FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.load [ARG String filepath=]>
java: ANN_MLP load(String filepath)
FUNC <TermCriteria cv.ml.ANN_MLP.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <double cv.ml.ANN_MLP.getBackpropMomentumScale []>
java: double getBackpropMomentumScale()
FUNC <double cv.ml.ANN_MLP.getBackpropWeightScale []>
java: double getBackpropWeightScale()
FUNC <double cv.ml.ANN_MLP.getRpropDW0 []>
java: double getRpropDW0()
FUNC <double cv.ml.ANN_MLP.getRpropDWMax []>
java: double getRpropDWMax()
FUNC <double cv.ml.ANN_MLP.getRpropDWMin []>
java: double getRpropDWMin()
FUNC <double cv.ml.ANN_MLP.getRpropDWMinus []>
java: double getRpropDWMinus()
FUNC <double cv.ml.ANN_MLP.getRpropDWPlus []>
java: double getRpropDWPlus()
FUNC <int cv.ml.ANN_MLP.getTrainMethod []>
java: int getTrainMethod()
FUNC <void cv.ml.ANN_MLP.setActivationFunction [ARG int type=, ARG double param1=0, ARG double param2=0]>
java: void setActivationFunction(int type, double param1, double param2)
java: void setActivationFunction(int type)
FUNC <void cv.ml.ANN_MLP.setBackpropMomentumScale [ARG double val=]>
java: void setBackpropMomentumScale(double val)
FUNC <void cv.ml.ANN_MLP.setBackpropWeightScale [ARG double val=]>
java: void setBackpropWeightScale(double val)
FUNC <void cv.ml.ANN_MLP.setLayerSizes [ARG Mat _layer_sizes=]>
java: void setLayerSizes(Mat _layer_sizes)
FUNC <void cv.ml.ANN_MLP.setRpropDW0 [ARG double val=]>
java: void setRpropDW0(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWMax [ARG double val=]>
java: void setRpropDWMax(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWMin [ARG double val=]>
java: void setRpropDWMin(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWMinus [ARG double val=]>
java: void setRpropDWMinus(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWPlus [ARG double val=]>
java: void setRpropDWPlus(double val)
FUNC <void cv.ml.ANN_MLP.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <void cv.ml.ANN_MLP.setTrainMethod [ARG int method=, ARG double param1=0, ARG double param2=0]>
java: void setTrainMethod(int method, double param1, double param2)
java: void setTrainMethod(int method)
CLASS cv.ml::.StatModel : Algorithm
[CONST UPDATE_MODEL=1, CONST RAW_OUTPUT=1, CONST COMPRESSED_INPUT=2, CONST PREPROCESSED_INPUT=4]
FUNC <bool cv.ml.StatModel.empty []>
java: boolean empty()
FUNC <bool cv.ml.StatModel.isClassifier []>
java: boolean isClassifier()
FUNC <bool cv.ml.StatModel.isTrained []>
java: boolean isTrained()
FUNC <bool cv.ml.StatModel.train [ARG Mat samples=, ARG int layout=, ARG Mat responses=]>
java: boolean train(Mat samples, int layout, Mat responses)
FUNC <bool cv.ml.StatModel.train [ARG Ptr_TrainData trainData=, ARG int flags=0]>
java: boolean train(TrainData trainData, int flags)
java: boolean train(TrainData trainData)
FUNC <float cv.ml.StatModel.calcError [ARG Ptr_TrainData data=, ARG bool test=, ARG Mat resp=]>
java: float calcError(TrainData data, boolean test, Mat resp)
FUNC <float cv.ml.StatModel.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>
java: float predict(Mat samples, Mat results, int flags)
java: float predict(Mat samples)
FUNC <int cv.ml.StatModel.getVarCount []>
java: int getVarCount()
CLASS cv.ml::.RTrees : DTrees
FUNC <Mat cv.ml.RTrees.getVarImportance []>
java: Mat getVarImportance()
FUNC <Ptr_RTrees cv.ml.RTrees.create []>
java: RTrees create()
FUNC <TermCriteria cv.ml.RTrees.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <bool cv.ml.RTrees.getCalculateVarImportance []>
java: boolean getCalculateVarImportance()
FUNC <int cv.ml.RTrees.getActiveVarCount []>
java: int getActiveVarCount()
FUNC <void cv.ml.RTrees.setActiveVarCount [ARG int val=]>
java: void setActiveVarCount(int val)
FUNC <void cv.ml.RTrees.setCalculateVarImportance [ARG bool val=]>
java: void setCalculateVarImportance(boolean val)
FUNC <void cv.ml.RTrees.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
